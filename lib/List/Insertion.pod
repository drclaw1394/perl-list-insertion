=head1 NAME

List::Insertion - Binary search a list for insertion point

=head1 SYNOPSIS

Export a named subroutine to locate the index of the first instance (left) of
value in a sorted simple scalar list:

  # Exports 'search_numeric_left' only
  #
  use List::Insertion {type=>"numeric", duplicate=>"left"};

  # Data has value 30 duplcated

  my @data=(10, 20, 30, 30, 40, 50, 60, 70);
  #index    0   1   2   3   4   5   6   7

  # The insert position will be index 2, which is left of duplicates
  #
  my $key= 30;
  my $pos=search_numeric_left $key, \@data;

  if($data[$pos] == $key){
    # Exact match, $pos is the index of the searched $key in the array (left)
  }
  else{
    # $pos is the index where $key should be inserted
  }  

Same as above with string comparison:

  use List::Insertion {type=>"string", duplicate=>"left"};

  my @data=qw<10 20 30 30 40 50 60 70>;
  #index      0  1  2  3  4  5  6  7

  my $key= "30";
  my $pos=search_string_left $key, \@data;

  if($data[$pos] eq $key){
  }
  else{
  }  

Export a named subroutine to search for insertion point, of array of hashes,
right of duplicates, with accessor to comparison value:

  # Data has value=>3 duplcated. Elements are hash refs so use an accessor snippet
  #
  use List::Insertion {type=>"numeric", duplicate=>"right", accessor=>'->{value}'};
  my @data=(
    {value=>1, other=>"a"},
    {value=>2, other=>"b"},
    {value=>3, other=>"c"},
    {value=>3, other=>"d"},
    {value=>4, other=>"e"},
    {value=>5, other=>"f"},
  );

  # The insert position will be index 4, which is right of duplicates
  #
  my $key= 3;
  my $pos=search_numeric_right $key, \@data;


Export 'make_search' and create anonymous routine instead of adding named
subroutines to name space

  use List:::Insertion "make_search";

  my @data=(1,2,3);

  my $search=List::Insertion::make_search type=>"numeric", duplicate=>"left";
  my $key=2;
  my $pos=$search->($key, \@data);

=head1 DESCRIPTION

L<List::Insertion> implements binary search algorithms to locate the
B<insertion> point of a sorted list for a given target value. If the value were
to be inserted at that position, the list would remain sorted.

A distinction is made between inserting left or right of an exact match or
duplicated entry. This allows to insert data before contiguous equal items or
after.

Performance rather than flexibility is favoured in the implementation and
necessitates the following restrictions on the data stored in the array/list
and how it's compared:

=over 

=item Data is expected to be sorted in asscending order only

This simplifies the combinations of subroutines exported

=item No code blocks can be specified

Code blocks need to be called. While they are ultimate if flexibility, 90% of
the functionality can be achieved with 'accessor' snippets.

=item Element comparision is implicitly numerical or string

No object methods for comparison. Only basic C<E<lt>=E<gt>>, C<E<gt>=>, C<le>
and C<ge> operators are used for internally for string and numeric comparison.

=item List element are homogeneous (no undefined items)

All items in the list are expected to have have the same data structure. This
can be a simple scalar like a string, or complex like array of arrays or hashes
of objects to any level of complexity.  It doesn't matter, as long as all the
items are of the same structure. When using complex scalars, the accessor
snippet is used as the code to access the value for search comparison.

=back

Although intended for searching of insertion point, this module can also be
used for general searching of elements. A simple check of equality between the
search key and  value at the found index will determine if the value was
actually found or not.

The returned index will never indicate 'not found' as there is always a insert
location in a list.

No symbols are exported by default and specification given at import time are
used to generate and export the search routine (s) needed. Anonymous search
subroutines can also be generated.

=head1  API

=head2 Importing

When importing this module, the type of comparison (string or numeric) and the
behaviour in dealing with duplicate values (left or right) is specified along
with optional accessor and prefix options.

Combinations of these options are generated via C<Data::Combination>, allowing
multiple subroutines to be configured and returned with minimal typing.

Consider the following examples:
    

    use List::Insertion {type=>"numeric", position=>left};                #(1)

    use List::Insertion {type=>"numeric", position=>["left", "right"]};   #(2)

    use List::Insertion {                                               #(3)
      type=>"numeric", duplicate=>["left", "right"], accessor=>'->{hash_key}'
    };

    use List::Insertion {                                               #(4)
      type=>"numeric", duplicate=>["left", "right"], accessor=>'->{hash_key}',
      prefix=>"find"};

=over

=item 1.

Imports the subroutine "search_numeric_left"

=item 2.

Imports the subroutines "search_numeric_left" and "search_numeric_right"

=item 3.

Imports the subroutines "search_numeric_left" and "search_numeric_right" and
uses the accessor '->{hash_key} when accessing elements. Elements must all be
hash references and the hash key will be compared in numeric fashion.

=item 4.

Imports the subroutines "find_numeric_left" and "find_numeric_right" and uses
the accessor '->method' when accessing elements. Elements must all respond to
'method', with its return value compared in numeric fashion.

=back


Supported options during importing include:

=head3 type

  type=>NAME or type=[NAME,...]

A plain scalar or array ref of comparison type names 
Supported values for NAME are:

=over

=item numeric, nv

Numerical comparison

=item string, pv

String comparison

=back

=head3 duplicate

  duplicate=>SIDE  or pos=>[SIDE,...]

A plain scalar or array ref of position names. This indicates the side to winch
the insert position will be adjusted when handling list items with the same
value.

Supported values for SIDE are:

=over

=item left, lesser

Choose the lower index when the duplicate items are encountered.


=item right, greater 

Choose the greater index (after duplicates) when the duplicate items are
encountered.


=back

=head3 accessor

  accessor=>STRING

A string consisting of perl post dereferencing/method call syntax, which is used
is to access internal levels of a list items data structure.

If not specified, elements in the list are treated as numeric/string simple
scalars. Their value are used directly in comparisons in the search algorithm.

If specified, elements are dereferenced/called with the accessor. The resulting
value is used in the comparison in the search algorithm.

=head3 prefix

  prefix=>STRING

A string which becomes the start of the imported subroutines name. If
unspecified, the string "search" is used.


=head2 Using Generated/Exported subrotines

The generated/imported subroutines are named in the format:

  prefix_type_duplicate

where prefix, type and duplicate represent the prefix, data type ( string or
numeric) and duplicated entry handling configuration


Routines are called with two arguments, the search key and reference to the sorted data:


    my $insert=find_nv_left $key, \@data;


The return value is the index in the C<@data>, which if inserting C<$key> will
keep the list sorted.


The value of the element located at C<$insert> my be equal to the search key.

B<NOTE:> Search routines never return less then 0 or otherwise indicate
'element not found'. The index is always the point when data can be inserted.
So an empty list will always return a found index of 0, as this where element
would be inserted.


=head2 Annonymous Subroutines

Instead of importing named subroutines into your namespace, anonymous
subroutines can be generated by importing the C<make_search> subroutine:

  use List::Insertion "make_search";

=head3 make_search

  my $sub=make_search {options}

Creates a search subroutine configured with a options hash ref. Each option is
a key value pair, as described in the B<importing> section. Only simple scalars
key/values are allowed, as only a single subroutine is returned per call.
Multiple calls to this subroutine will need to be used to generate multiple
search subroutines.

This is the subroutine called internally during import to generate the named
subroutines.

The option B<prefix> has no effect as the routine is anonymous.


=head1 SEE ALSO

L<List::BinarySearch> and the L<List::BinarySearch::PP>(pure perl)  and
L<List::BinarySearch::XS> (XS enhanced) 'sub modules' provide more flexibility
than this module. Mainly because of the use of code blocks are used for element
comparison.

However this module which is also pure perl is about 5-6x as fast as the
L<List::BinarySearch::PP> module and is only half the speed of the
L<List::BinarySearch::XS> module.

In terms of performance of a 10000 element numeric sorted list:

                Rate L::BS::PP      L::I L::BS::XS
  L::BS::PP  12667/s        --      -83%      -91%
  L::I       74472/s      488%        --      -49%
  L::BS::XS 144807/s     1043%       94%        --


=head1 REPOSITORY and BUG REPORTING

Please report any bugs and feature requests on the repo page:
L<GitHub|http://github.com/drclaw1394/perl-list-insertion>

=head1 AUTHOR

Ruben Westerberg, E<lt>drclaw@mac.comE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2023 by Ruben Westerberg

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, or under the MIT license

=head1 DISCLAIMER OF WARRANTIES

THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE.

=cut
